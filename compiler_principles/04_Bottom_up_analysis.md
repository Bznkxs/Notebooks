# Bottom-up analysis

## 概念

> 为了得到“句柄”的概念来进行归约，也是拼了。
>
> 句柄就是右句型里面的一个直接短语。
>
> 短语就是一个可归约串。

- 可归约串：文法的某个句型，如果将它的某个子串归约之后可以得到文法的另一个句型，那么就称该子串为可归约串。

  - 也就是说，aaaab中的前两个aa，归约成A以后原句变成Aaab，如果S=>\* Aaab，那么这两个aa就是可归约串。但是如果你把第二个第三个a归约为A，原句是aAab，没法归约到S，那么就是不可归约串了。

- 短语：若S=><sup>\*</sup> &alpha;A&delta;且A=><sup>+</sup>&beta;，那么beta是&alpha;&beta;&delta;的一个短语。

  - &alpha;&beta;&delta;是一个句型。所以可归约串就是短语。
  - 求句型的所有短语，你只需要写出分析树（把句型当果实），那么以每个结点为根，其子树的果实就是一个短语。

- 直接短语：一步归约。对应到分析树上，就是属于同一个父亲的一系列结点。

  ![tree](img\0301)

  |          | aaab                                                         | aaAb                                               |
  | -------- | ------------------------------------------------------------ | -------------------------------------------------- |
  | 短语     | **aaa&epsilon;b**<br />**aaa&epsilon;**b<br />a**aa&epsilon;**b<br />aa**a&epsilon;**b<br />aaa**&epsilon;**b<br />aaa&epsilon;**b** | **aaAb**<br />**aaA**b<br />a**aA**b<br />aaA**b** |
  | 直接短语 | aaa**&epsilon;**b<br />aaa&epsilon;**b**                     | a**aA**b<br />aaA**b**                             |

- 句柄：是右句型的直接短语；而且其父亲是一个右句型。

  - 等价于选择最左的直接短语。因为在最右推导的前提下，非最左的直接短语肯定已经被推导过了。比如aaab的b作为一个直接短语，必然比epsilon更先推导。
  - 为啥要选最左的嘞？你想想，我是从下往上归约，那么如果我要得到最右推导，最右边的是不是应该最后才归约？
  - 首先构造一个到该短语的最右推导。那么最后一步推导的就是句柄。

  S =><sub>rm</sub> AB =><sub>rm</sub> Ab =><sub>rm</sub> aAb =><sub>rm</sub> aaAb =><sub>rm</sub> aaaAb =><sub>rm</sub> aaa&epsilon;b，所以eps是aaab的句柄

  看前四步推导，就知道aA是aaAb句柄

  你可以猜测：LR(1)分析要求的是句柄的唯一性

## 移进-归约分析

一个栈+一个引擎

分析栈中有#，通过不断从序列把单词移入栈、再用产生式归约，最后分析栈中留存#S、符号串只有#时成功

动作：Reduce, Shift, Error, Accept

- Shift：从输入序列移进一个单词符号

表驱动的移进-归约分析模型：查询分析表确定下一步动作。

移进归约冲突：下一步不知道是该移进还是该归约

归约归约冲突：可能对多个短语进行归约

## LR分析

LR(left-to-right, rightmost derivation)

对句柄进行归约

首先是产生一个状态机，用状态机的状态来代替符号

分析表：ACTION表和GOTO表

ACTION[k, a] = si, rj, acc, err：栈顶状态为k，当前输入单词为a；si是将状态i移入栈；rj是按第j条产生式归约

GOTO[i, A]：按A->beta归约以后栈顶状态如何改变，A->beta要先弹出|beta|个状态，如果弹出以后的当前状态为i就把GOTO[i, A]入栈

在方便的情况下可以让分析栈既包含状态又含符号

### LR(0)分析

1. 产生原文法的增广文法：S' -> S
2. 活前缀：以句柄为后缀的句型子串的任何前缀都叫做活前缀；换句话说，活前缀是右句型的前缀，而且不超过该句型的某个句柄
   - 分析栈上可能出现的符号串都是活前缀。啊，你说为啥嘞？因为只要出现句柄，就被归约了呗，所以不会超过句柄

#### LR(0)状态机

> 项目：一个记录匹配位置的“产生式”，根据"."后面的符号分为移进、待约、归约、接受项目
>
> 状态：项目的传递闭包，通过待约项目的待约符号发生传递
>
> 转移函数：一个状态里面的一个项目的小圆点往右边移一位就到达了另一个状态

1. LR(0)项目：右端有一个圆点的产生式。A->xyz对应四个LR(0)项目A->.xyz, A->x.yz, A->xy.z, A->xyz.
   - 表示已分析过的串和产生式匹配的位置。根据未匹配的第一个位置的特征可以分为四种情况。
   - 移进项目：A->&alpha;.a&beta;
   - 待约项目：A->&alpha;.B&beta;
   - 归约项目：A->&alpha;.
   - 接受项目：S'->S.
2. 状态机的状态是LR(0)项目集I的闭包CLOSURE(I)
   - 闭包通过“待约”的传递性来获得：遇到待约项目A->a.B，就把待约符号B的所有产生式对应的初始项目B->.c, B->.d, B->.C放到闭包里，以此类推
   - 状态机的初态是CLOSURE({S'->.S})
   - 状态机的末态是CLOSURE({S'->S.})
3. 状态机的转移函数：如果I是一个状态，A->&alpha;.X&beta;属于该状态，而A->&alpha;X.&beta;属于J状态，那么GO(I, X)=J
   - 由状态的传递闭性质可以知道这是个DFA

#### LR(0)分析表

首先要对所有状态编号呀！现在状态列表为{I[k]}

当然也要对产生式编号

1. 待约项目：GO（弹栈后的符号）

   GOTO完全根据GO的非终结符建立，只是改成编号：

   ​	GOTO(k, X) = GO(I[k], X)的编号

   把X归约以后就要转移到这个状态来嘛

2. 移进项目：移进

   对于转移GO(I[k], a)=I[j]，a是终结符，ACTION[k, a]=sj

3. 归约项目：归约

   对于归约项目A->&alpha;.所在的I[k]，对任何终结符都要归约，ACTION[k, 任何终结符]=ri，i是产生式的编号

4. 接受项目：接受

   末态I[n]=CLOSURE({S'->S.})，则ACTION[n, #]=acc

- LR(0)文法：这张LR(0)表没有重项

#### LR(0)文法的限制在状态机中的体现

每个状态不同时含有移进和归约项目（s-r冲突）

> 表格上来看，该状态移进对应的表项出现s和r
>
> 那我到了你这个状态，是该移进呢，还是该归约呢

状态不含有两个以上归约项目（r-r冲突）

> 表格上来看，该状态的每个表项有多个r（显然，多个归约项目来自多个产生式，因为来自同一个产生式的归约项目的点的位置不可能一样，状态可是集合啊）
>
> 我该用哪个式子归约呢

### SLR(1)分析

> 一切都是为了在归约上面做动作啊

#### SLR(1)分析表

在LR(0)分析表的归约上面做手脚（任何终结符太随意了）：

​	对于归约项目A->&alpha;.所在的I[k]，**以及Fo(A)中的a，**ACTION[k, a]=ri

现在s-r和r-r都得到一定程度上的解决

每个状态中，对移进项目A->sdf.ab, 不存在B的归约项目使得Fo(B)含有a

> 表格上看，归约的那几项不希望有移进

每个状态中，任何两个归约项目的Fo不要有交集

> 归约不要有重复的

但是，Fo是针对任意句型的，而没有充分利用句柄的限制

### LR(1)分析

#### LR(1)有限状态机

- LR(1)项目比LR(0)项目多了一个终结符“向前搜索符”，用于归约而不是移进

  - 含义是：这个项目的圆点移到最后的时候，要用这个符号才能归约

  A->a.b, x

  A->a.b, x/y/z/#

- LR(1)的状态闭包：[A->&alpha;.B&beta;, a]可以传递到[B->.x, b]，如果b是属于Fi(&beta;a)

  - 看，这很显然！毕竟是用于归约。首先，如果&beta;里面有非空的，那么B归约的时候遇到beta里面的是不是可以归约？其次，如果beta含空，那么B遇到a是不是可以归约？是不是？？
  - I0=CLOSURE({[S'->.S, #]})

- 转移：只有相同的向前搜索符才可以转移（毕竟是用于归约）

#### LR(1)分析表

向前搜索符的存在感：归约的时候，如果是项目[A->a., b]，那么只有ACTION[k, b]=rj；其他不变

LR(1)文法：状态如果有移进（A->sd.a, x）就没有对应的归约（B->?., a）；不要有两个向前搜索符一样的归约

### LALR(1)分析

#### LALR(1)状态机

项目的“芯”是去掉搜索符的部分。

同芯：芯完全相同的状态

把同芯状态合并的状态机叫LALR(1)状态机

逐步合并法：在LR(1)状态机产生算法中，每产生一个新状态就判断是否与已有状态同芯

与LR(0)同状态数，比SLR(1)强而比LR(1)弱

## 二义文法的LR分析

优先级：E+E., E.+E, E.\*E，遇\*移进

左结合：遇+归约

悬挂else：优先移进

## 错误处理

应急恢复：试图隔离由所选非终结符推导的最短可能出错的子串，丢弃，继续分析

即兴恢复：对每个表项确定一个最可能的出错情形