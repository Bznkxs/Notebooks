# 8. 运行时存储组织

## 逻辑存储区域

保留地址区：不允许用户访问

代码区：存放代码

**静态数据区**：静态的全局数据

共享区和分别编译模块区：通过链接器linker，把运行时支持（IO/storage/debugging）和外部包（数学库）装入到当前的存储空间

**动态数据区**：运行时动态变化的**堆区**和**栈区**，一般堆从低向高，栈从高往低

### 静态存储分配

编译期间确定对象大小和数目

通常将地址对应到(DataAreaStart, Offset)，DataAreaStart在运行时确定

### 栈式存储分配

使用活动记录作为栈式分配的存储单元

### 堆式存储分配

存储分配方式：怎样得到堆式存储

​	显式/隐式的空间分配和释放命令

存储分配算法：得到的是哪一块

​	最佳适应算法：空间浪费最少；

​	最先适应算法：最先找到的满足要求的块；

​	循环最先适应算法：每次起点不同

## 活动记录

### 栈帧

过程活动记录=栈帧

其中的数据一般采用寄存器偏址寻址方式来访问

#### 动态数组

动态数组是在运行时知道其上界的，保存的时候需要放在所有静态数据之后

```
p(){
	int a;
	...
	int d[a];
	int c;
}
```



| 控制信息      |
| ------------- |
| a             |
| 内情向量（a） |
| d的起始位置p  |
| c             |
| d             |
| ...           |

内情向量存的是d的上界，相当于要在上面代码的第四行把a赋给这个块。

对于两个/两个以上动态数组，第二个以后的数组无法静态地确定起始位置。

#### 嵌套过程定义 之 非局部量的访问

有几个形成要素：

```python
def A():
	def B():
		x = 1
		def C():
			pass
# 仅仅假设A可以调用B，B可以调用A和C，C可以调用A和B
```



1. 嵌套过程定义，也就是过程里面套过程，此时里面的过程C可以访问外层过程A的对象
2. 在里过程C被调用的时候，外过程中的局部数据对象x可以被访问

这个叫做非局部量（不在当前活动记录中）的访问。复杂之处在于，1非局部量不能通过当前栈帧基址+偏移来获得，需要记录对应外过程的栈帧基址；2嵌套的过程可能会多次调用，也就是过程的栈帧基址的记录也要随着递归过程而更新。

##### Display表

记录嵌套层**最后一次**活动记录的**起始地址**

上面是3层嵌套（主程序层次为0，主程序在这里是A外面的部分，**主程序不能递归调用**），那么Display表有4项(0,1,2,3)，分别对应主程序/A/B/C的活动记录。

比如栈帧为[ main A B A B C>（假设栈帧大小为1）

那么D[0]=0，D[1]=3，D[2]=4，D[3]=5

递归调用很好维护，但返回时怎么恢复呢？

- 可以将Display表全部放入活动记录中

- 可以将Display表发生改变的一项放入活动记录中

  - 发生改变的当然只有自己啦。所以记录的是自己这一项原来的值。原来的值不存在的记为_：

    | 层数 | 活动记录                  |
    | ---- | ------------------------- |
    | 0    | main<br />saved (D[0]): _ |
    | 1    | A<br />saved (D[1]): _    |
    | 2    | B<br />saved (D[2]): _    |
    | 3    | A<br />saved (D[1]): 1    |
    | 4    | B<br />saved (D[2]): 2    |
    | 5    | C<br />saved (D[3]): _    |

##### 静态链

比如B call C

静态链也叫访问链

在活动记录增加一个域，记录**定义这个过程的外过程**在**调用发生的时间点**的最新的活动记录

C的活动记录总是指向B，B的活动记录总是指向A。

1. A call B: [main A B>，static[2] = 1  B --> A
2. B call C: [main A B C>, static[3] = 2  C --> B
3. C call B: [main A B C B>, static[4] = 1  B --> A
4. B call C: [main A B C B C>, static[5] = 4  C --> B

动态链也叫控制链：其实就是旧的fp【栈帧基址】，它总是指向上一个活动记录。

#### 嵌套程序块的非局部量访问

这个我会，相对位置在编译的时候就已确定，所以不要创建块级活动记录。

### 动态作用域规则和静态作用域规则

动态作用域的作用域是基于调用的，也就是说，如果A调用B，那么B就可以访问A的变量。注意Python是静态作用域规则，而Pascal是动态作用域规则。**静态作用域规则用静态链一层层往外找，动态作用域规则用动态链一层层往外找。**

## 过程调用和参数传递



### 调用过程

“调用代码序列”为活动记录分配空间，由被调用和调用过程分工完成

“返回代码序列”恢复机器状态，由被调用过程完成

“调用约定”：规定调用代码序列和返回代码序列的分工

1. 调用起始阶段，调用过程和被调用过程分工完成：
   - 参数传递（寄存器、栈）
   - 分配空间
   - 保存动态链(旧fp)，保存调用过程的返回地址、保存其它控制信息、寄存器信息
   - 新的fp、新的sp
   - 控制转移，开始执行被调用过程
2. 调用收尾阶段
   - 返回值存入寄存器/栈
   - 恢复寄存器
   - 弹出栈帧，恢复旧栈帧
   - 控制返还

### 参数传递

- 传值：是右值
- 传地址：是左值
- 对于传地址的参数，其参数存储空间放的是地址，取值方式跟普通变量不同，但对使用者透明

搞不懂，算咯