# 8. 运行时存储组织

## 逻辑存储区域

保留地址区：不允许用户访问

代码区：存放代码

**静态数据区**：静态的全局数据

共享区和分别编译模块区：通过链接器linker，把运行时支持（IO/storage/debugging）和外部包（数学库）装入到当前的存储空间

**动态数据区**：运行时动态变化的**堆区**和**栈区**，一般堆从低向高，栈从高往低

### 静态存储分配

编译期间确定对象大小和数目

通常将地址对应到(DataAreaStart, Offset)，DataAreaStart在运行时确定

### 栈式存储分配

使用活动记录作为栈式分配的存储单元

### 堆式存储分配

存储分配方式：怎样得到堆式存储

​	显式/隐式的空间分配和释放命令

存储分配算法：得到的是哪一块

​	最佳适应算法：空间浪费最少；

​	最先适应算法：最先找到的满足要求的块；

​	循环最先适应算法：每次起点不同

## 活动记录

### 栈帧

过程活动记录=栈帧

其中的数据一般采用寄存器偏址寻址方式来访问

#### 动态数组

动态数组是在运行时知道其上界的，保存的时候需要放在所有静态数据之后

```
p(){
	int a;
	...
	int d[a];
	int c;
}
```



| 控制信息      |
| ------------- |
| a             |
| 内情向量（a） |
| d的起始位置p  |
| c             |
| d             |
| ...           |

内情向量存的是d的上界，相当于要在上面代码的第四行把a赋给这个块。

对于两个/两个以上动态数组，第二个以后的数组无法静态地确定起始位置。

#### 嵌套过程定义 之 非局部量的访问

有几个形成要素：

```python
def A():
	def B():
		x = 1
		def C():
			pass
# 仅仅假设A可以调用B，B可以调用A和C，C可以调用A和B
```



1. 嵌套过程定义，也就是过程里面套过程，此时里面的过程C可以访问外层过程A的对象
2. 在里过程C被调用的时候，外过程中的局部数据对象x可以被访问

这个叫做非局部量（不在当前活动记录中）的访问。复杂之处在于，1非局部量不能通过当前栈帧基址+偏移来获得，需要记录对应外过程的栈帧基址；2嵌套的过程可能会多次调用，也就是过程的栈帧基址的记录也要随着递归过程而更新。

##### Display表

记录嵌套层**最后一次**活动记录的**起始地址**

上面是3层嵌套（主程序层次为0，主程序在这里是A外面的部分，**主程序不能递归调用**），那么Display表有4项(0,1,2,3)，分别对应主程序/A/B/C的活动记录。

比如栈帧为[ main A B A B C>（假设栈帧大小为1）

那么D[0]=0，D[1]=3，D[2]=4，D[3]=5

递归调用很好维护，但返回时怎么恢复呢？

- 可以将Display表全部放入活动记录中
- 可以将Display表