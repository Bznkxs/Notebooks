# 4. 语法制导语义计算

## 属性文法

为符号关联属性，并为产生式关联语义动作或条件谓词

### 语义动作

使用产生式时执行相关动作

语义函数f：语义动作表示为b:=f(x,y,z)或单独的f(x,y,z)

y:=x称为复写规则

### 条件谓词

如A.num=B.num，条件谓词为真才可以应用产生式

课程不讨论条件谓词

### 属性

综合属性：如果A的某个属性是通过产生式右边赋给左边的，自底向上传递：A->a {A.s:=1}

继承属性：如果A的某个属性是赋给右边的，自顶向下传递：S->AB {A.a:=S.a, B.a:=A.s}

### 依赖图

对于输入串，这样进行语义计算：

- 在语法分析树中构造依赖图：
  - 对每个属性建一个节点
  - 对每个f(x,y,z)的语义动作建一个虚节点，从x,y,z向其连边
  - 对每个语义动作b:=f(x,y,z)，从x,y,z向b连边
- 若依赖图是无圈的则可以按依赖图的拓扑排序进行遍历，否则该步骤失效

计算语法分析树结点属性的过程称为“标注”，属性的计算结果写在树节点旁边，叫做“带标注的语法分析树”

## 语法制导的语义计算

语法制导的含义是利用语法分析的过程，也即语义动作就在这样一个自顶向下或自底向上的过程中顺便完成。

需要给出属性文法的限制：S-属性文法和L-属性文法

### S- and L- 

只包含综合属性的S-属性文法

L-属性文法可以包含继承属性，但如A->RSTU，T只能依赖于它前面的(1) R, S的属性和(2) A的**综合属性**

#### S-

自底向上，栈里面同时也要放综合属性值。在分析过程中列的表格多一列：语义动作，归约时完成。例如归约到

A.a=X.x+Y.y+Z.z

此时属性栈顶的top, top-1, top-2分别对应z,y,x

| step | 分析栈 | 剩余输入 | 分析动作 | 语义动作 |
| ---- | ------ | -------- | -------- | -------- |
|      |        |          |          |          |

#### L-

先自顶向下分析（从左至右），得到所有继承属性值

然后回溯时计算综合属性值

下推栈不仅存储符号，也存储语义动作，这样操作：

#### 不考

- 当开始使用推导时，弹出产生式左部，入栈自底向上语义动作，从右到左将产生式右部入栈，符号入栈后将语义动作入栈

  A->{B.x=A.x}B{C.x=B.x}C{A.y=B.y+C.y} 的操作为

  从[A>变成

  [{A.y=B.y+C.y} C {C.x=B.x} B {B.x=A.x}>

## 基于翻译模式的语义计算

### S- and L-翻译模式

本质上与属性文法一致，但翻译模式规定好了语义动作的处理次序：继承属性在对应符号之前处理，综合属性在产生式分析完成后处理。

此外，注意如果有多个相同符号，对它们编号：比如第一个S，第二个标S1，第三个标S2

#### S-翻译模式的计算

把产生式

`A->XYZ { A.a:=X.a+2*Y.a+3*Z.a}`

用栈的次序表示，变换为

`A->XYZ {v[top-2].a:=v[top-2].a+2*v[top-1.a]+3*v[top.a]}`

top意味着归约前的栈顶位置

#### L-自顶向下

程序设计中如何引入语义计算？在函数Parse中，将继承属性作为参数传入；函数返回综合属性。

比如 S -> {B.f:=S.f} B {S1.f:=B.val} S1 {S.val:=B.val+S1.val}

```python
def ParseS(f):
    if lookahead in PS("S->BS"):
        Bf = f
        Bv = ParseB(Bf)
        S1f = Bv
        S1v = ParseS(S1f)
        Sv = Bv + S1v
    else:
        pass
    return Sv
```

消除左递归：对于A的每个综合属性，新符号Q定义两个属性，一个用来向下传递左边的属性，一个用来向上传递式子的属性

#### L-自底向上

只需处理产生式中间的语义动作，将继承属性归结到某个综合属性，然后用S属性文法来处理

首先做变换

- 继承属性不是通过复写规则定义的：引入符号，修改

  - S->A{C.i:=A.s+1}C

  - ----

    S->A{M.i:=A.s}M{C.i:=A.s}C,

  - M->eps{M.s:=M.i+1}

- 继承属性的访问存在的位置不一样：引入非终结符，强制让其位置相同

  - S->A{C.i:=A.s}C | Ab{C.i:=A.s}C

  - ---

    S->A{C.i:=A.s}C | Ab{M.i:=A.s}M{C.i:=M.s}C

  - M->eps{M.s:=M.i}

这之后，可以将继承属性归到某个综合属性，用栈表示

